#include <iostream>
#include <fstream>
#include <math.h>
#include <chrono>
#include <clocale>
#include <windows.h>
#include "vectors.h"

#define COUNT_THREADS 2

using namespace std;
using namespace chrono;

struct screen_resolution;
class mesh;
class vizor;
class Obj;

void Resolution();
void screen_view(mesh A, vizor Player, ofstream& out);
XYZ get_pixel(mesh M, vizor P);
void obj_print(Obj A_Obj);
double Radius_finder(Obj Some);
Obj* Obj_Maker(Obj *All_Obj, ifstream& Obj_adr);
void Obj_Radius_Maker(Obj *All_Obj);
POINT dCursor(POINT Cursor_dt);
void Obj_Create_New(ofstream& Obj_adr_end);
void Resolution_out();
void Player_eye(VOID);
DWORD WINAPI THR_exit_catch(LPVOID param);
DWORD WINAPI THR_Vn_Creator(LPVOID param);
DWORD WINAPI Rat_Trasing(void * param);

struct screen_resolution{
    int shirina;
    int vysota;
};

//struct Pix_RGB{
//    short int R = 0;
//    short int G = 0;
//    short int B = 0;
//};
//
//struct Image{           // NEED?
//    **Pix_RGB;
//};

class mesh {
private:

public:
    XYZ A, B, C;
    XYZ ab, ac, n;
    mesh(){
        A.x = A.y = A.z = B.x = B.y = B.z = C.x = C.y = C.z = 0;
    }
    void mesher(ifstream& file){
//        ifstream file("vectors.txt");
        A = vf(A, file);
        B = vf(B, file);
        C = vf(C, file);
//        file.close();
        ab = o_vector(A, B);
        ab = o_vector(A, B);
        ac = o_vector(A, C);
        n = vector_normal(ab, ac);
        n = vector_sim(n);
    }
//    void mesh_new(XYZ A_new,XYZ B_new,XYZ C_new){ // Сырая функция
////        ifstream file("vectors.txt");
//        A = A_new;
//        B = B_new;
//        C = C_new;
////        file.close();
//        ab = o_vector(A, B);
//        ab = o_vector(A, B);
//        ac = o_vector(A, C);
//        n = vector_normal(ab, ac);
//        n = vector_sim(n);
//    }
};

class vizor {
public:
    XYZ O;
    XYZ V;
    XYZ ov;
    XYZ V1 = V;
    XYZ O1 = O;
    XYZ E0;
    vizor (){
        ifstream file("vizor.txt");
        O = vf(O, file);
        V = vf(V, file);
        file.close();
        V1 = V;
        O1 = O;
    }
//    rotation (){
//
//    }
};

class Obj {
private:
public:
    bool live;
    char Name[100];
    double Radius;
    int num_meshs = 0;
    mesh *B = new mesh[num_meshs];
    Obj(){}
    void Objj(ifstream& file){
        file >> num_meshs;
        mesh *C = new mesh[num_meshs];
        mesh A;
        for (int k = 0; k < num_meshs; k++){
            A.mesher(file);
            C[k] = A;
        }
        B = C;
//        cout << "Is error is here?" << B[0].A.x << endl;
//        delete[]C;
//        cout << "Here????????" << B[0].A.x << endl;
    }
//    void Obj_New(mesh A){             // Сырая функция
//        file >> num_meshs;
//        mesh *C = new mesh[num_meshs];
//        mesh A;
//        for (int k = 0; k < num_meshs; k++){
//            A.mesh_new();
//            C[k] = A;
//        }
//        B = C;
//    }
};

struct Image;                   // NEED?

int N;
screen_resolution resolution;
//XYZ DM_Picture[768][1366];
char f_exit = 0;

int main()
{
    auto Game_Start = steady_clock::now();
    setlocale(LC_CTYPE, "rus");
    POINT Cursor_dt;

    Resolution();

//    ifstream file("vectors.txt");
//    mesh A;
//    A.mesher(file);
//    file.close();
    ::N = 0;

    char Adress_Objects[] = {"Game_Objects/Objects_adress.txt"};

    vizor Player;
    cout << "Желаете ли создать новые объекты в папку игры?" << endl << "1 -> Да" << endl;
    int answer;
    cin >> answer;
    if(answer == 1){
        ofstream Obj_adr_end(Adress_Objects, ios_base::app);
        Obj_Create_New(Obj_adr_end);
        Obj_adr_end.close();
    }
    else{cout << "Окей, идем дальше" << endl;}

//    ofstream out("page.txt");
//    for (int i = 0; i < 24; i++){
//        Cursor_dt = dCursor(Cursor_dt);
////        screen_view(A, Player, out);
//        cout << Cursor_dt.x << " " << Cursor_dt.y << endl;
//        Sleep(50);
//    }
//    out.close();

    ifstream Obj_adr(Adress_Objects);
    Obj *All_Obj;
    All_Obj = Obj_Maker(All_Obj, Obj_adr);
//    for(int j = 0; j < N; j++){
//        cout << "Object " << j+1 << " parameters" << endl;
//        obj_print(All_Obj[j]);
//        cout << endl;
//    }
//    cout << "Do you want to make Radius for some objects?" << endl;
    cout << "Найти и записать радиусы для некоторых объектов?" << endl;
    cin >> answer;
    if(answer == 1)
        Obj_Radius_Maker(All_Obj);
    else cout << "Нет так нет..." << endl << endl;
    auto Game_End = steady_clock::now();
    auto elapsed_ms = duration_cast<milliseconds>(Game_End - Game_Start);
    cout << "Time spend: " << elapsed_ms.count() << " ms" << endl;
//    HINSTANCE hInstance;
//    HINSTANCE nPrevInstance;
//    LPSTR lpCmdLine;
//    int CmdShow;
//    WinMain(hInstance, nPrevInstance, lpCmdLine, CmdShow);
    Player_eye();
    cout << "Game Ends here. Thanks for testing!" << endl;
    Sleep(1000);
    return 0;
}
//int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE nPrevInstance, LPSTR lpCmdLine, int CmdShow)
//{
//    char str[] = "Fuck\nReally shit";
//    MessageBox(NULL, str, "My Window", MB_ICONSTOP);
//}
void Resolution_out()
{
    cout << resolution.shirina << " " << resolution.vysota;
}

POINT dCursor(POINT Cursor_dt)
{
    GetCursorPos(&Cursor_dt);
    SetCursorPos(resolution.shirina/2,resolution.vysota/2);
    Cursor_dt.x = Cursor_dt.x - resolution.shirina/2;
    Cursor_dt.y = Cursor_dt.y - resolution.vysota/2;
    return Cursor_dt;
}

typedef struct TempMesh{
    XYZ tMesh[3];
    struct TempMesh *next;
} TempMesh;


void Obj_Create_New(ofstream& Obj_adr_end)
{
    short answer = 0, ans_1, ans_2, ans_3;
    cout << "Введите имя нового объекта: ";
    char tName[100] = {"Game_Objects/"}, Name[100], NameSuffics[] = {".txt"}, TempName[100];
    int N_obj = 0;
    cin >> TempName;
    strcat(tName,TempName);
    strcat(tName,NameSuffics);
    OemToChar(tName,Name);
    ofstream obj_new(Name);
//    obj_new << endl;

    cout << "Задайте первые три точки: ";
    TempMesh *mesh_now;
    mesh_now = new TempMesh;
    XYZ A[3];
    for(int i = 0; i < 3; i++){
        cin >> A[i].x >> A[i].y >> A[i].z;
        mesh_now->tMesh[i] = A[i];
    }
    TempMesh *first;
    first = new TempMesh;
    first->next = mesh_now;
    N_obj++;
    cout << "Что делаем дальше?/n1)Добавить точку к предыдущему мешу/n2)Создать новый меш/3)Завершить работу с файлом" << endl;
    while(answer!=3){
        cin >> answer;
        if(answer == 1){
            cout << "Какие точки выбрать?" << endl;
            for(int i = 0; i < 3; i++){
                cout << i + 1 << ") ";
                vector_print(A[i]);
            }
            cin >> ans_1 >> ans_2;
            while((ans_1 != 1 && ans_1 != 2 && ans_1 != 3) || (ans_2 != 1 && ans_2 !=2 && ans_2 != 3) || (ans_1 == ans_2)){
                cout << "Некорректный выбор, 1, 2 или 3!\nВыбери ещё раз" << endl;
                cin >> ans_1 >> ans_2;
            }
            cout << endl;

            cout << "Введите координаты новой точки: ";
            if(ans_1 != 1 && ans_2 != 1)
                ans_3 = 0;
            if(ans_1 != 2 && ans_2 != 2)
                ans_3 = 1;
            if(ans_1 != 3 && ans_2 != 3)
                ans_3 = 2;
            cin >> A[ans_3].x >> A[ans_3].y >> A[ans_3].z;
            TempMesh *TempA = new TempMesh;
            for(int i = 0; i < 3; i++)
                TempA->tMesh[i] = A[i];
            mesh_now->next = TempA;
            mesh_now = mesh_now->next;
            N_obj++;
            cout << "Готово. Что дальше?" << endl;
            continue;
        }
        if(answer == 2){
            cout << "Введите координаты трех новых точек:" << endl;
            for(int i = 0; i < 3; i++)
                cin >> A[i].x >> A[i].y >> A[i].z;
            TempMesh *TempA = new TempMesh;
            for(int i = 0; i < 3; i++)
                TempA->tMesh[i] = A[i];
            mesh_now->next = TempA;
            mesh_now = mesh_now->next;
            N_obj++;
            cout << "Готово. Что дальше?" << endl;
            continue;
        }
        if(answer == 3){
            mesh_now = first->next;
            obj_new << N_obj;
            for(int i = 0; i < N_obj; i++){
                for(int j = 0; j < 3; j++)
                    obj_new << endl << mesh_now->tMesh[j].x << " " << mesh_now->tMesh[j].y << " " << mesh_now->tMesh[j].z;
                mesh_now = mesh_now->next;
            }

            ifstream obj_new_read(Name);
            Obj New;
            New.Objj(obj_new_read);
            obj_new_read.close();
            double L;
            L = Radius_finder(New);
            obj_new << endl << L;
            obj_new.close();
            Obj_adr_end << endl << Name;
            break;
        }
        if(answer!=1&&answer!=2&&answer!=3){
            cout << "Более корректно, чувак..." << endl;
            continue;
        }
    }
    cout << endl << "Успешно!" << endl << endl;
}

void Obj_Radius_Maker(Obj *All_Obj)
{
//    for(int i = 0; i < N; i++)
//        cout << "Object " << i + 1 << " live is " << All_Obj[i].live << endl;
    int k = -1;
    char t[100];
    short choose = 1;
    while(choose==1){
        cout << "Выберите объект для расчёта радиуса" << endl;
        cin >> k;
        while(k < 1 || k > N){
            cout << "Данный объект не существует, выберите другой" << endl;
            cin >> k;
        }
        if(All_Obj[k - 1].live == 0){
            cout << "С этим объектом проблемы, выберите другой" << endl;
            cin >> k;
            while(k < 1 || k > N){
                cout << "Данный объект не существует, выберите другой" << endl;
                cin >> k;
            }
            if(All_Obj[k - 1].live == 0){
                cout << "С этим тоже проблемы... ещё раз (или -1 для выхода)" << endl;
                cin >> k;
                if(k == -1){
                    cout << "Успешно сдались!" << endl;
                    break;
                }
                while(k < 1 || k > N){
                    cout << "Данный объект не существует, выберите другой" << endl;
                    cin >> k;
                    if(k == -1){
                        cout << "Успешно сдались!" << endl;
                        break;
                    }
                }
                while(All_Obj[k - 1].live == 0){
                    cout << "D'oh! И с этим..." << endl;
                    cin >> k;
                    if(k == -1){
                        cout << "Успешно сдались!" << endl;
                        break;
                    }
                    while(k < 1 || k > N){
                        cout << "Данный объект не существует, выберите другой" << endl;
                        cin >> k;
                        if(k == -1){
                            cout << "Успешно сдались!" << endl;
                            break;
                        }
                    }
                }
            }
        }
        if(k == -1)
            break;
        double L;
        L = Radius_finder(All_Obj[k-1]);
//        cout << "Radius is " << L << endl;
        for(int i = 0; i < 100; i++){
            t[i] = All_Obj[k-1].Name[i];
        }
        ifstream check(t);
        int counter = -1;
        double temp;
        while(!check.eof()){
            check >> temp;
            counter++;
        }
        cout << "Counter = " << counter << endl;
        if(counter%9 == 0){
            ofstream write(t, ios_base::app);
            write << endl << L;
            cout << "Сохранён. Ещё для одного?" << endl;
//            cout << "Saved. Do next?" << endl;
            cin >> choose;
        }
        else {
            if((counter-1)%9 == 0){
                int tt, ll;
                tt = temp*10000;
                ll = L*10000;
//                cout << endl << "Last double is: " << temp << endl;
//                cout << "Last L is: " << L << endl << endl;
//                cout << endl << "tt: " << tt << endl;
//                cout << "ll: " << ll << endl << endl;
//                cout << "ll - tt" << ll - tt << endl << endl;
                if(ll == tt)
                    cout << "Уже имеет радиус" << endl << "Выбрать другой объект?" << endl;
                else cout << "((or) some shit in the end of the file:)" << endl << "Выбрать более удачный объект?" << endl;
//                cout << "Already have Radius (or some shit in the end of the file:)" << endl << "Choose else object?" << endl;
            }
            else cout << "Объект сломан..." << endl << "Выбрать другой?" << endl;
            cin >> choose;
        }
    }
}

Obj* Obj_Maker(Obj *All_Obj, ifstream& Obj_adr)
{
    if(!Obj_adr.is_open()){
        cout << "*******Не могу найти адреса объектов игры*******" << endl;
//        cout << "Can't find Game Objects adresses" << endl;
        Sleep(5000);
    }

    char s[100], t[100];
    cout << "Подсчёт количества объектов..." << endl;
    while(!Obj_adr.eof()){
        Obj_adr >> s;
        ::N++;
    }
    cout << "Поиск объектов..." << endl;
    Obj_adr.seekg(0,ios_base::beg);
    All_Obj = new Obj[N];
    int k = 0;

    while(!Obj_adr.eof()){
        Obj_adr >> s;
        OemToChar(s,t);
        ifstream obj_1(t);
        if (!obj_1.is_open()){
            cout << "Ошибка с файлом " << s << "." << endl;
            All_Obj[k].live = 0;
            k++;
            continue;
        } else {cout << "Файл " << s << " найден" << endl;}
        All_Obj[k].Objj(obj_1);
        for(int i = 0; i < 100; i++){
            All_Obj[k].Name[i] = t[i];
        }
        All_Obj[k].live = 1;
        k++;
    }
    return All_Obj;
}

double Radius_finder(Obj Some){      // ОБЯЗАТЕЛЬНО ПЕРЕДЕЛАТЬ (смотри ниже)
    double L = 0, tL;
    XYZ tochka[Some.num_meshs*3];
    for(int i = 0, j = 0; i < Some.num_meshs; i++){ // Во время инициализации проверять на совпадение точек
        tochka[j] = Some.B[i].A;                    // со всеми предыдущими, не создавать одинаковые.
        tochka[j+1] = Some.B[i].B;
        tochka[j+2] = Some.B[i].C;
        j += 3;
    }
//    cout << endl << "ТОЧКИ:" << endl << endl;
//    for(int i = 0; i < Some.num_meshs*3; i++){
//        vector_print(tochka[i]);
//    }
//    cout << endl << "Длины:" << endl << endl;
    for(int i = 0; i < Some.num_meshs*3; i++){
        for(int j = i+1; j < Some.num_meshs*3; j++){
            if(tochka[i].x == tochka[j].x){
                if(tochka[i].y == tochka[j].y){
                    if(tochka[i].z == tochka[j].z){
                        continue;
                    }
                    tL = tochka[i].z - tochka[j].z;
                    if(tL < 0)
                        tL = -tL;
                    if(tL > L)
                        L = tL;
//                    cout << "tL: " << tL << " L: " << L << endl;
                    continue;
                }
            }
            tL = vector_module(o_vector(tochka[i], tochka[j]));
            if(tL > L)
                L = tL;
//            cout << "tL: " << tL << " L: " << L << endl;
        }
    }
//    cout << "Диаметр: " << L << endl;
    L /= 2;
    cout << "Радиус: " << L << endl;
    return L;
}

void obj_print(Obj A_Obj)
{
    for (int i = 0; i < A_Obj.num_meshs; i++){
        cout << "Mesh " << i+1 << " is:" << endl;
        vector_print(A_Obj.B[i].A);
        vector_print(A_Obj.B[i].B);
        vector_print(A_Obj.B[i].C);
        cout << endl;
    }
}

XYZ get_pixel(mesh M, vizor P)
{
    XYZ AV, OS, OV, PIXEL;
    double pv, ov, vs, alpha, k;
    AV = o_vector(M.A, P.V);
    pv = vector_SP(M.n, AV);
    OV = o_vector(P.O, P.V);
    ov = vector_module(OV);
    alpha = vector_SP(M.n, OV) / ov;
    vs = -pv / alpha;
    OS = OV;
    k = vs / ov;
    OV = vector_YnC(OV, k);
    OS = vector_sum(OS, OV);
    PIXEL = vector_return_tochky(OS, P.O);

    return PIXEL;
}
/*
void screen_view(mesh A, vizor Player, ofstream& out) // ПЕРЕПИСАТЬ, ДАННАЯ - ДЛЯ ЕДИНИЧНОГО СЛУЧАЯ!!!!!
{
    XYZ PIXEL;
    auto begin = steady_clock::now();
    double dVy, dSh; // НЕ ЗАБЫТЬ - ПОКА БЕСПОЛЕЗНЫ, ПРИВЯЗАТЬ

    for(int i = 0; i < resolution.vysota; i++){
//        out << "Line " << i << " is ";
        Player.V.y -= 3;
        for(int j = 0; j < resolution.shirina; j++){
            Player.V.y += 0.002;
            PIXEL = get_pixel(A, Player);
//            out << PIXEL.x << " " << PIXEL.y << " " << PIXEL.z << " ";
        }
//        out << endl;
        Player.V.y = Player.V1.y;
        Player.V.z -= 0.002;
    }
    Player.V.z = Player.V1.z;
    auto end = steady_clock::now();
    auto elapsed_ms = duration_cast<milliseconds>(end - begin);
    cout << "Time spend: " << elapsed_ms.count() << " ms" << endl;
}
*/
void Resolution()
{
    cout << "Введите Ваше разрешение экрана (ширина х высота) или выберите из предложенных:" << endl;
    cout << "1) 800x400\n2)1200x768\n3)1366x768" << endl;
    int choise;
    cin >> choise;
    switch(choise){
    case 1:
        resolution.shirina = 800;
        resolution.vysota = 400;
        break;
    case 2:
        resolution.shirina = 1200;
        resolution.vysota = 768;
        break;
    case 3:
        resolution.shirina = 1366;
        resolution.vysota = 768;
        break;
    default:
        resolution.shirina = choise;
        cin >> resolution.vysota;
        break;
    }
}


///                             CLEAN EYE PROGRAMM

//                  Ради сонхронизации можно создать доп элемент в структуре
//                  изображения с типом bool, и переменять её на 1, если изображение
//                  уже было задействовано, и 0 - если это новое изображение. То же
//                  самое можно сделать для отрисовки и пр. (но оптимизированно ли это?)

//int main()
//{
//    Player_eye();
//    return 0;
//}

void Player_eye(VOID)
{
    HANDLE threads[COUNT_THREADS];
    threads[0] = CreateThread(NULL, 0, THR_exit_catch, NULL, 0, 0);
    threads[1] = CreateThread(NULL, 0, THR_Vn_Creator, NULL, 0, 0);
//    threads[2] = CreateThread(NULL, 0, Mesh_Finder, NULL, 0, 0);
    WaitForMultipleObjects(COUNT_THREADS, threads, TRUE, INFINITE);
}

DWORD WINAPI THR_exit_catch(LPVOID param)
{
    while(::f_exit == 0)
        cin >> ::f_exit;
    ExitThread(0);
}


//XYZ DM_Picture[768][1366];

DWORD WINAPI THR_Vn_Creator(LPVOID param)
{
    POINT DCursor;
    COORD FPS_Where, Look_Where, CLEAN_CONSOLE;
    FPS_Where.X = 50;
    FPS_Where.Y = 3;
    Look_Where.X = 20;
    Look_Where.Y = 4;
    CLEAN_CONSOLE.X = 0;
    CLEAN_CONSOLE.Y = 0;
    HANDLE hOut;
    hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    auto Game_Start = steady_clock::now();
    auto Game_End = steady_clock::now();
    auto elapsed_ms = duration_cast<milliseconds>(Game_End - Game_Start);

    double Alpha = 0, Beta = 0, temp_proeczia, dDCursorX, dDCursorY;
    XYZ E0, Ez{0,0,1}, eVys, eShi, dEVys, dEShi, V;
//    int N = 1366, M = 768;
    XYZ** DM_Picture;
    DM_Picture = new XYZ*[resolution.vysota];
    for (int i = 0; i < resolution.vysota; i++)
        DM_Picture[i] = new XYZ[resolution.shirina];

    double dShi, dVys;
    dShi = 1.0 / 600;
    dVys = 1.0 / 600;
    int iii = 0;
    double fps = 0.0;
    int sec = 0;
    double fps_sec = 0.0;
    SetCursorPos(resolution.shirina/2,resolution.vysota/2);
    cout << "ALL GOOD" << endl;
//    XYZ DM_Picture[768][1366];
    cout << "ALL GOOD222" << endl;
    SetConsoleCursorPosition(hOut,
                            CLEAN_CONSOLE);
    for(int i = 0; i < 60; i++){
        for(int j = 0; j < 10; j++)
            cout << "\t";
        cout << endl;
    }
//    while (DCursor.x == 0 && DCursor.y == 0)
//        DCursor = dCursor(DCursor);
    HANDLE threads[1];
    while(::f_exit == 0){
        Game_Start = steady_clock::now();
        DCursor = dCursor(DCursor);
        dDCursorX = DCursor.x;
        dDCursorY = DCursor.y;
        Beta += dDCursorY / resolution.vysota;
        if(Beta > 3.14/2)
            Beta = 3.14/2;
        if(Beta < -3.14/2)
            Beta = -3.14/2;
        Alpha += dDCursorX/resolution.shirina;
        E0.z = sin(Beta);
        temp_proeczia = cos(Beta);
        E0.x = temp_proeczia*sin(Alpha);
        E0.y = temp_proeczia*cos(Alpha);
        eShi = vector_perp(E0,Ez);
        eShi = vector_ration(eShi);
        eVys = vector_perp(E0,eShi);
        eVys = vector_ration(eVys);
        dEShi = vector_YnC(eShi,dShi);
        dEVys = vector_YnC(eVys,dVys);
        V.x = E0.x + dEShi.x*(resolution.shirina/2) + dEVys.x*(resolution.vysota/2);
        V.y = E0.y + dEShi.y*(resolution.shirina/2) + dEVys.y*(resolution.vysota/2);
        V.z = E0.z + dEShi.z*(resolution.shirina/2) + dEVys.z*(resolution.vysota/2);
        for(int i = 0; i < resolution.vysota; i++){           // i < 768
            for(int j = 0; j < resolution.shirina - 1; j++){      // j < 1365
                DM_Picture[i][j] = V;
                V.x -= dEShi.x;
                V.y -= dEShi.y;
                V.z -= dEShi.z;
            }
            DM_Picture[i][resolution.shirina - 1] = V;
            V.x += dEShi.x*resolution.shirina;
            V.y += dEShi.y*resolution.shirina;
            V.z += dEShi.z*resolution.shirina;
            V.x -= dEVys.x;
            V.y -= dEVys.y;
            V.z -= dEVys.z;
        }
//        WaitForMultipleObjects(1, threads, TRUE, INFINITE);
        threads[0] = CreateThread(NULL, 0, Rat_Trasing, (void*)&DM_Picture, 0, 0);
        Game_End = steady_clock::now();
        elapsed_ms = duration_cast<milliseconds>(Game_End - Game_Start);
        sec += elapsed_ms.count();
        fps_sec += elapsed_ms.count();
        iii++;
        fps++;
        if(fps == 15){
            SetConsoleCursorPosition(hOut,
                                    FPS_Where);
            cout << "fps: " << (fps/(fps_sec/1000)) << "    " << endl;
            fps_sec = 0;
            fps = 0;
        }
        SetConsoleCursorPosition(hOut,
                                Look_Where);
        cout << "\t\tX:" << DM_Picture[resolution.vysota/2][resolution.shirina/2].x;
        cout << " \tY: " << DM_Picture[resolution.vysota/2][resolution.shirina/2].y;
        cout << " \tZ: " << DM_Picture[resolution.vysota/2][resolution.shirina/2].z << "\t\t\t" << endl;
    }
    cout << "Srednee fps: " << ((iii*1000)/(sec)) << endl;
    cout << "Vremya: " << sec << endl;
    double Sec = sec;
    cout << "Srednee vremya: " << Sec / iii << endl;
    Sleep(1000);
    ExitThread(0);
}

DWORD WINAPI Rat_Trasing(LPVOID param)
{

}

///                             END OF CLEAN EYE PROGRAMM


//DWORD WINAPI Rat_Trasing(void * param)
//{
//    cout << "ALL THREAD1 " << endl;
//    XYZ** * DM_Picture = (XYZ** *)param;
//    cout << "ALL THREAD2 " << endl;
//    cout << endl << "Pic is: " << DM_Picture[1][1]->x << endl;
////     << " " << DM_Picture[1][1]->y << " " << DM_Picture[1][1]->z << "\t" << endl;
//    cout << "ALL THREAD3 " << endl;
//    ExitThread(0);
//}
